resource "random_string" "module_prefix" {
  length  = 6
  special = false
}

locals {
  prefix = lower(random_string.module_prefix.result)
}

module "cosmo_federated_graph" {
  source            = "../cosmo-federated-graph"
  namespace         = "${var.stage}-${local.prefix}"
  router_token_name = "${var.stage}-${local.prefix}-router-token"

  federated_graph = {
    name        = "${local.prefix}-federated-graph"
    readme      = "The federated graph for the local setup"
    routing_url = "http://localhost:3000"
    label_matchers = [
      "team=backend",
    ]
  }
  subgraphs = {
    "availability" = {
      name        = "${var.stage}-${local.prefix}-availability"
      routing_url = "http://example.com/routing"
      schema      = <<EOF
      extend schema
      @link(url: "https://specs.apollo.dev/federation/v2.5", import: ["@authenticated", "@composeDirective", "@external", "@extends", "@inaccessible", "@interfaceObject", "@override", "@provides", "@key", "@requires", "@requiresScopes", "@shareable", "@tag"])

      type Mutation {
          updateAvailability(employeeID: Int!, isAvailable: Boolean!): Employee!
      }
      type Employee @key(fields: "id") {
        id: Int!
        isAvailable: Boolean!
      }
      EOF
      readme      = <<EOF
# Overview

The availability subgraph contains information about the availability of employees.

# Mutations

The following mutations are available:

## updateAvailability

Updates the availability of an employee.

# Model

The following model is used:

```
// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.
package model

type Employee struct {
	ID          int  `json:"id"`
	IsAvailable bool `json:"isAvailable"`
}

func (Employee) IsEntity() {}

type Mutation struct {
}

type Query struct {
}
```
      EOF
      labels = {
        "team"  = "backend"
        "stage" = "${var.stage}"
      }
    }
    "products" = {
      name        = "${var.stage}-${local.prefix}-products"
      routing_url = "http://example.com/routing"
      schema      = <<EOF
      extend schema
      @link(url: "https://specs.apollo.dev/federation/v2.5", import: ["@authenticated", "@composeDirective", "@external", "@extends", "@inaccessible", "@interfaceObject", "@override", "@provides", "@key", "@requires", "@requiresScopes", "@shareable", "@tag"])

      schema {
        query: Queries
        mutation: Mutation
      }

      type Queries {
        productTypes: [Products!]!
        topSecretFederationFacts: [TopSecretFact!]! @requiresScopes(scopes: [["read:fact"], ["read:all"]])
        factTypes: [TopSecretFactType!]
      }

      type Mutation {
        addFact(fact: TopSecretFactInput!): TopSecretFact! @requiresScopes(scopes: [["write:fact"], ["write:all"]])
      }

      input TopSecretFactInput {
        title: String!
        description: FactContent!
        factType: TopSecretFactType!
      }

      enum TopSecretFactType @authenticated {
        DIRECTIVE,
        ENTITY,
        MISCELLANEOUS,
      }

      interface TopSecretFact @authenticated {
        description: FactContent!
        factType: TopSecretFactType
      }

      scalar FactContent @requiresScopes(scopes: [["read:scalar"], ["read:all"]])

      type DirectiveFact implements TopSecretFact @authenticated {
        title: String!
        description: FactContent!
        factType: TopSecretFactType
      }

      type EntityFact implements TopSecretFact @requiresScopes(scopes: [["read:entity"]]){
        title: String!
        description: FactContent!
        factType: TopSecretFactType
      }

      type MiscellaneousFact implements TopSecretFact {
        title: String!
        description: FactContent! @requiresScopes(scopes: [["read:miscellaneous"]])
        factType: TopSecretFactType
      }

      enum ProductName {
        CONSULTANCY
        COSMO
        ENGINE
        FINANCE
        HUMAN_RESOURCES
        MARKETING
        SDK
      }

      type Employee @key(fields: "id") {
        id: Int!
        products: [ProductName!]!
        notes: String @override(from: "employees")
      }

      union Products = Consultancy | Cosmo | Documentation

      type Consultancy @key(fields: "upc") {
        upc: ID!
        name: ProductName!
      }

      type Cosmo @key(fields: "upc") {
        upc: ID!
        name: ProductName!
        repositoryURL: String!
      }

      type Documentation {
        url(product: ProductName!): String!
        urls(products: [ProductName!]!): [String!]!
      }
      EOF
      readme      = <<EOF
# Overview

The products subgraph contains information about the different products that the company offers.

# Mutations

The following mutations are available:

## addFact

Adds a new fact to the product.

# Model

The following model is used:

```
// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.
package model

import (
  "fmt"
  "io"
  "strconv"
)

type Products interface {
  IsProducts()
}

type TopSecretFact interface {
  IsTopSecretFact()
  GetDescription() string
  GetFactType() *TopSecretFactType
}

type Consultancy struct {
  Upc  string      `json:"upc"`
  Name ProductName `json:"name"`
}

func (Consultancy) IsProducts() {}

func (Consultancy) IsEntity() {}

type Cosmo struct {
  Upc           string      `json:"upc"`
  Name          ProductName `json:"name"`
  RepositoryURL string      `json:"repositoryURL"`
}

func (Cosmo) IsProducts() {}

func (Cosmo) IsEntity() {}

type DirectiveFact struct {
  Title       string             `json:"title"`
  Description string             `json:"description"`
  FactType    *TopSecretFactType `json:"factType,omitempty"`
}

func (DirectiveFact) IsTopSecretFact()                     {}
func (this DirectiveFact) GetDescription() string          { return this.Description }
func (this DirectiveFact) GetFactType() *TopSecretFactType { return this.FactType }

type Documentation struct {
  URL  string   `json:"url"`
  Urls []string `json:"urls"`
}

func (Documentation) IsProducts() {}

type Employee struct {
  ID       int           `json:"id"`
  Products []ProductName `json:"products"`
  Notes    *string       `json:"notes,omitempty"`
}

func (Employee) IsEntity() {}

type EntityFact struct {
  Title       string             `json:"title"`
  Description string             `json:"description"`
  FactType    *TopSecretFactType `json:"factType,omitempty"`
}

func (EntityFact) IsTopSecretFact()                     {}
func (this EntityFact) GetDescription() string          { return this.Description }
func (this EntityFact) GetFactType() *TopSecretFactType { return this.FactType }

type MiscellaneousFact struct {
  Title       string             `json:"title"`
  Description string             `json:"description"`
  FactType    *TopSecretFactType `json:"factType,omitempty"`
}

func (MiscellaneousFact) IsTopSecretFact()                     {}
func (this MiscellaneousFact) GetDescription() string          { return this.Description }
func (this MiscellaneousFact) GetFactType() *TopSecretFactType { return this.FactType }

type Mutation struct {
}

type Queries struct {
}

type TopSecretFactInput struct {
  Title       string            `json:"title"`
  Description string            `json:"description"`
  FactType    TopSecretFactType `json:"factType"`
}

type ProductName string

const (
  ProductNameConsultancy    ProductName = "CONSULTANCY"
  ProductNameCosmo          ProductName = "COSMO"
  ProductNameEngine         ProductName = "ENGINE"
  ProductNameFinance        ProductName = "FINANCE"
  ProductNameHumanResources ProductName = "HUMAN_RESOURCES"
  ProductNameMarketing      ProductName = "MARKETING"
  ProductNameSdk            ProductName = "SDK"
)

var AllProductName = []ProductName{
  ProductNameConsultancy,
  ProductNameCosmo,
  ProductNameEngine,
  ProductNameFinance,
  ProductNameHumanResources,
  ProductNameMarketing,
  ProductNameSdk,
}

func (e ProductName) IsValid() bool {
  switch e {
  case ProductNameConsultancy, ProductNameCosmo, ProductNameEngine, ProductNameFinance, ProductNameHumanResources, ProductNameMarketing, ProductNameSdk:
    return true
  }
  return false
}

func (e ProductName) String() string {
  return string(e)
}

func (e *ProductName) UnmarshalGQL(v interface{}) error {
  str, ok := v.(string)
  if !ok {
    return fmt.Errorf("enums must be strings")
  }

  *e = ProductName(str)
  if !e.IsValid() {
    return fmt.Errorf("%s is not a valid ProductName", str)
  }
  return nil
}

func (e ProductName) MarshalGQL(w io.Writer) {
  fmt.Fprint(w, strconv.Quote(e.String()))
}

type TopSecretFactType string

const (
  TopSecretFactTypeDirective     TopSecretFactType = "DIRECTIVE"
  TopSecretFactTypeEntity        TopSecretFactType = "ENTITY"
  TopSecretFactTypeMiscellaneous TopSecretFactType = "MISCELLANEOUS"
)

var AllTopSecretFactType = []TopSecretFactType{
  TopSecretFactTypeDirective,
  TopSecretFactTypeEntity,
  TopSecretFactTypeMiscellaneous,
}

func (e TopSecretFactType) IsValid() bool {
  switch e {
  case TopSecretFactTypeDirective, TopSecretFactTypeEntity, TopSecretFactTypeMiscellaneous:
    return true
  }
  return false
}

func (e TopSecretFactType) String() string {
  return string(e)
}

func (e *TopSecretFactType) UnmarshalGQL(v interface{}) error {
  str, ok := v.(string)
  if !ok {
    return fmt.Errorf("enums must be strings")
  }

  *e = TopSecretFactType(str)
  if !e.IsValid() {
    return fmt.Errorf("%s is not a valid TopSecretFactType", str)
  }
  return nil
}

func (e TopSecretFactType) MarshalGQL(w io.Writer) {
  fmt.Fprint(w, strconv.Quote(e.String()))
}
  ```
      EOF
      labels = {
        "team"  = "backend"
        "stage" = "${var.stage}"
      }
    }
  }

  depends_on = [
    module.minikube,
    module.cosmo_release
  ]
}
 